# Description: Cog that houses utilities commands for NBC Boterator

import app_logger
import config
import discord
import platform
import os
import psutil
import subprocess
import sys
import time

from datetime import datetime
from discord.ext import commands
from discord.ext.commands.cooldowns import BucketType
from typing import Optional
from utils import tools

logger = app_logger.get_logger(__name__)


class UtilitiesCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.suggest_channel = self.bot.get_channel(
            config.SUGGEST_CHANNEL_ID
        )

    def cog_unload(self):
        for h in logger.handlers:
            logger.removeHandler(h)

    def get_local_version():
        # Grab version num from a local file previously generated by the
        # GitHub release-please action
        with open("version.txt") as f:
            bot_version = f.readline()

        recent_commit = "Unknown"
        commit_date = "Unknown"

        try:
            git_log = subprocess.check_output(
                ["git", "log", "-n", "1", "--date=iso"]
            ).decode()

            for line in git_log.split("\n"):
                if line.startswith("commit"):
                    recent_commit = line.split(" ")[1]
                elif line.startswith("Date"):
                    commit_date = line[5:].strip()  # Might need to amend the splicing value
                    commit_date = commit_date.replace(" +", "+").replace(" ", "T")
                else:
                    pass
        except Exception as e:
            # ...
            raise e

        return bot_version, recent_commit, commit_date

    def get_remote_commits():
        pass

    @commands.command(aliases=["botinfo", "info"])
    async def about(self, ctx):
        # Grab version number generated by GitHub release-please action
        with open("version.txt") as f:
            bot_version = f.readline()
            logger.debug(
                "Parsed Bot Version (%s)", bot_version  # TODO: Strip newline character
            )

        # Get version info for library and python runtime
        disc_version = discord.__version__
        py_version = sys.version[0:5]

        # Get bots' total uptime
        delta_uptime = datetime.utcnow() - self.bot.launch_time
        friendly_uptime = tools.fmt_seconds_friendly(
            delta_uptime.total_seconds()
        )

        # Calculate websocket latency
        web_latency = self.bot.latency * 1000

        # Calculate bot python process memory usage
        pid = os.getpid()
        py = psutil.Process(pid)
        bot_memory_usage = round(py.memory_info()[0]/(10**6), 2)

        embed = discord.Embed(
            title=f"About - {config.BOT_AUTHOR_NAME}",
            description="This is the server's custom discord bot, created for "
                        "the purpose of making everyone's lives easier. It's "
                        "fairly barebones feature-wise right now, but that'll "
                        "change as development continues."
                        f"\n\n{config.BOT_EMOJI_GITHUB} **[GitHub]"
                        f"({config.BOT_GITHUB_HOME})**"
                        f"\n{config.BOT_EMOJI_YOUTUBE} **[YouTube Channel]"
                        f"({config.BOT_YOUTUBE_CHANNEL})**"
                        f"\n{config.BOT_EMOJI_CLOUD} **[Website (WIP)]"
                        f"({config.BOT_URL})**",
            colour=config.BOT_COLOUR
        )
        embed.set_thumbnail(
            url=self.bot.user.avatar_url
        )
        embed.add_field(
            name="Developer: ",
            value="`Lukadd.16#8870`",
            inline=True
        )
        embed.add_field(
            name="Bot Version:",
            value=f"`{bot_version}`",
            inline=True
        )
        embed.add_field(
            name="Uptime: ",
            value=f"`{friendly_uptime}`",
            inline=True
        )
        embed.add_field(
            name="Python Version: ",
            value=f"`{py_version}`",
            inline=True
        )
        embed.add_field(
            name="Library Version: ",
            value=f"`Discord.py {disc_version}`",
            inline=True
        )
        embed.add_field(
            name="Websocket Ping: ",
            value="`{:.2f}ms`".format(web_latency),
            inline=True
        )
        embed.add_field(
            name="RAM Usage: ",
            value=f"`{bot_memory_usage} MB`",
            inline=True
        )
        embed.add_field(
            name="PLACEHOLDER: ",
            value="`placeholder`",
            inline=True
        )
        embed.add_field(
            name="Server OS: ",
            value=f"`{platform.system()}`",
            inline=True
        )
        embed.set_footer(
            text=config.BOT_FOOTER
        )
        await ctx.send(embed=embed)

    @commands.command(aliases=["av"])
    async def avatar(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
            logger.debug(
                "No member specified in %s command, defaulting to author",
                ctx.command
            )

        user_pfp = member.avatar_url_as(
            format=None,
            static_format="png",
            size=256
        )

        embed = discord.Embed(
            title=f"Avatar – `{member.name}#{member.discriminator}`",
            description=member.mention,
            colour=config.BOT_COLOUR,
            timestamp=ctx.message.created_at
        )
        embed.set_author(
            name=config.BOT_AUTHOR_CLICK,
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.set_image(
            url=user_pfp
        )
        embed.set_footer(
            text=f"Requested by {ctx.author.name}#{ctx.author.discriminator}",
            icon_url=f"{ctx.author.avatar_url}"
        )

        await ctx.send(embed=embed)

    @commands.command(aliases=["version", "whatsnew"])
    async def changelog(self, ctx):
        # Grab version num from a local file previously generated by the
        # GitHub release-please action
        with open("version.txt") as f:
            bot_version = f.readline()

        embed = discord.Embed(
            description=f"**Local Version:** [{bot_version}]"
                        f"({config.BOT_GITHUB_LATEST})\n"
                        "> A full changelog can be viewed via the above "
                        "hyperlink.",
            colour=config.BOT_COLOUR
        )
        embed.set_author(
            name="NBC Boterator Changelog",
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.set_footer(
            text=config.BOT_FOOTER
        )
        await ctx.send(embed=embed)

    @commands.command(aliases=["joinposition", "jpos"])
    @commands.guild_only()
    async def joinpos(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
            logger.debug(
                "No member specified in %s command, defaulting to author",
                ctx.command
            )

        member_join_position = tools.get_join_position(ctx, member)
        msg = f"*{member.name}* is member `#{member_join_position}` "\
              f"(out of {len(ctx.guild.members)})"

        await ctx.send(msg)

    @commands.command()
    async def ping(self, ctx):
        # Start stopwatch used for latency calculation
        start = time.perf_counter()
        logger.debug("Ping timer started")

        embed = discord.Embed(
            colour=config.BOT_COLOUR
        )
        embed.set_author(
            name="NBC Boterator Response Times",
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.add_field(
            name="Ping...",
            value="Message Round Trip: "
                  "\nDiscord Websocket: "
        )
        embed.set_footer(
            text=config.BOT_FOOTER
        )
        message = await ctx.send(embed=embed)

        # End stopwatch; Calculate cmd round-trip and websocket latencies
        end = time.perf_counter()
        logger.debug("Ping timer ended")
        duration = (end - start) * 1000
        web_latency = self.bot.latency * 1000

        embed = discord.Embed(
            colour=config.BOT_COLOUR
        )
        embed.set_author(
            name=config.BOT_AUTHOR_CLICK,
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.set_thumbnail(
            url=self.bot.user.avatar_url
        )
        # :.2f cuts latency values down to two decimal places
        embed.add_field(
            name="Pong!",
            value="Message Round Trip: `{:.2f}ms`"
                  "\nDiscord Websocket: `{:.2f}ms`".format(
                      duration, web_latency
                  )
        )
        embed.set_footer(
            text=config.BOT_FOOTER
        )
        await message.edit(embed=embed)

    # TODO: Bot currently does not handle 403 Missing Access error
    #       (which occurs when the bot can't see the mentioned channel)
    @commands.command(aliases=["pins", "pinfo"])
    async def pinned(self, ctx, channel: Optional[discord.TextChannel] = None):
        if channel is None:
            channel = ctx.channel

        # Retrieve all pinned messages as a List[Message]
        pinned_messages = await channel.pins()

        # Count # of pinned messages in the channel
        total_pins = len(pinned_messages)

        # Create response embed
        embed = discord.Embed(
            title=f"Pinned Messages - `#{channel.name}`",
            description=channel.mention,
            colour=config.BOT_COLOUR,
            timestamp=ctx.message.created_at
        )
        embed.set_author(
            name=config.BOT_AUTHOR_CLICK,
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.add_field(
            name="Channel ID:",
            value=f"{channel.id}",
            inline=False
        )
        embed.add_field(
            name="# of Pinned Messages:",
            value=f"{total_pins} (max permitted is 50)",
            inline=False
        )
        embed.set_footer(
            text=f"Requested by {ctx.author.name}#{ctx.author.discriminator}",
            icon_url=f"{ctx.author.avatar_url}"
        )

        # Retrieve most recent pinned message & relevant details about it
        # Embed field will be different depending on the existance of a
        # pinned message
        try:
            recent_pin = pinned_messages[0]

            # Retrieve first few characters from message
            recent_pin_brief = recent_pin.content[0:40]

            if recent_pin_brief == "":
                # Message string is empty, which means the actual message
                # contains an embed or attachment
                recent_pin_brief = "Cannot preview, message is an embed/attachment"
            else:
                recent_pin_brief += " (...)"

            # Retrieve message author
            recent_pin_author = (
                recent_pin.author.mention
                + f" ({recent_pin.author.id})"
            )

            # Retrieve date message was created
            recent_pin_date = recent_pin.created_at
            friendly_recent_pin_date = tools.fmt_time_friendly(
                recent_pin_date
            )

            # Get discord.com/channels/ link to the message
            recent_pin_url = recent_pin.jump_url

            embed.add_field(
                name="Most Recent Pin:",
                value=f"**Author:** {recent_pin_author}"
                      f"\n**Created:** {friendly_recent_pin_date} GMT"  # TODO: Add "# days ago"?
                      f"\n**Content:** {recent_pin_brief}"
                      f"\n> [Jump To Message]({recent_pin_url})",
                inline=False
            )
        except IndexError:  # Channel has no pinned messages
            embed.add_field(
                name="Most Recent Pin:",
                value="The specified channel has no pinned messages",
                inline=False
            )

        await ctx.send(embed=embed)

    # Deprecated, remove entirely in a future release
    @commands.command()
    async def uptime(self, ctx):
        delta_uptime = datetime.utcnow() - self.bot.launch_time
        hours, remainder = divmod(int(delta_uptime.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
        days, hours = divmod(hours, 24)
        await ctx.send(
            "I have been online for "
            f"{days}d, {hours}h, {minutes}m, {seconds}s, Sir"
        )

    @commands.command(aliases=["userinfo", "uinfo"])
    @commands.guild_only()
    async def whois(self, ctx, *, member: discord.Member = None):
        if member is None:
            member = ctx.author
            logger.debug(
                "No member specified in %s command, defaulting to author",
                ctx.command
            )

        logger.debug("Debug Stack:")

        # Get various information about user
        # snowflake_time is outputted in the form of datetime.datetime
        user_createdate = discord.utils.snowflake_time(
            member.id
        )
        logger.debug(
            "> (datetime.datetime) Account Created On: %s", user_createdate
        )

        # Convert account creation time to readable format
        friendly_user_createdate = tools.fmt_time_friendly(
            user_createdate
        )
        logger.debug(
            "> (tools) Account Created On: %s", friendly_user_createdate
        )

        # Convert guild join time to readable format
        friendly_member_joindate = tools.fmt_time_friendly(
            member.joined_at
        )
        logger.debug(
            "> (tools) Joined Guild On: %s",
            friendly_member_joindate
        )

        # Returns member's join position out of all guild members
        member_join_position = tools.get_join_position(
            ctx,
            member
        )
        logger.debug(
            "> (tools) Join Position in Guild: %s", member_join_position
        )

        # Returns an emoji if member is a bot
        bot_identify = tools.do_bot_check(
            member
        )
        logger.debug("> (tools) User is a bot? %s", bot_identify)

        # Returns an emoji dynamic to member's online status
        status_emoji = tools.get_member_status(
            member
        )
        logger.debug("> (tools) User Status: %s", status_emoji)

        # Subtract by 1 to omit the @everyone role
        member_role_sum = len(member.roles) - 1
        logger.debug("> Role Count: %s", member_role_sum)

        # Check sum of member.roles list, if member has no roles
        # return None to prevent 400 Bad Request Error.
        # Else perform list manipulation logic.
        if member_role_sum == 0:
            member_role_list = None
        elif member_role_sum >= 1:
            # Separate each role by a single space
            member_role_list = ' '.join(
                [
                    r.mention for r in member.roles[:0:-1]
                ]
            )
        logger.debug("> List of Roles: %s", member_role_list)

        # Now that I understand how to get roles, make a system that loops
        # through user's roles (from highest to lowest) finding the first one
        # that has a colour other than the default invisible one

        embed = discord.Embed(
            title=f"User Info – `{member.name}#{member.discriminator}`"
                  f"{status_emoji}{bot_identify}",
            description=f"{member.mention}",
            colour=config.BOT_COLOUR,
            timestamp=ctx.message.created_at
        )
        embed.set_author(
            name=config.BOT_AUTHOR_CLICK,
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.set_thumbnail(
            url=member.avatar_url
        )
        embed.add_field(
            name="Account Created (GMT):",
            value=f"{friendly_user_createdate}",
            inline=True
        )
        embed.add_field(
            name="Joined Guild (GMT):",
            value=f"{friendly_member_joindate}",
            inline=True
        )
        embed.add_field(
            name="Join Position:",
            value=f"{member_join_position} of {len(ctx.guild.members)}",
            inline=True
        )
        embed.add_field(
            name="User ID:",
            value=f"{member.id}",
            inline=True
        )
        embed.add_field(
            name="Nickname:",
            value=f"{member.nick}",
            inline=True
        )
        embed.add_field(
            name=f"Roles [{member_role_sum}]:",
            value=f"{member_role_list}",
            inline=False
        )
        embed.set_footer(
            text=f"Requested by {ctx.author.name}#{ctx.author.discriminator}",
            icon_url=(ctx.author.avatar_url)
        )
        await ctx.send(embed=embed)

    # WIP
    @commands.command(aliases=["sinfo"], enabled=False)
    @commands.guild_only()
    async def serverinfo(self, ctx):
        embed = discord.Embed(
            title=f"Server Info - `{ctx.guild.name}`",
            colour=config.BOT_COLOUR
        )
        embed.set_author(
            name=config.BOT_AUTHOR_CLICK,
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        # Set thumbnail to be the server's icon
        # Should work with both animated and static
        embed.set_thumbnail(
            url=ctx.guild.icon_url
        )
        # Create list of features/info/stats that I want to include

        embed.set_footer(
            text=f"Requested by {ctx.author.name}#{ctx.author.discriminator}",
            icon_url=(ctx.author.avatar_url)
        )
        await ctx.send(embed=embed)

    # Users are only allowed to use this command once every 30 seconds
    # TODO: Should add JSON file + ability to blacklist users from sending
    #       suggestions (then do the same for global cmd blacklist)
    @commands.command()
    @commands.cooldown(1, 30, type=BucketType.user)
    @commands.guild_only()
    async def suggest(self, ctx, *, user_suggestion: str):
        if len(user_suggestion) >= 512:
            logger.info(
                "User Suggestion Too Long"
            )
            logger.info(
                "> Offending User: %s#%s",
                ctx.author.name,
                ctx.author.discriminator
            )

            embed = discord.Embed(
                title="ERROR",
                description="Your suggestion cannot be more than 512 "
                            "characters in length, please try to shorten it.",
                colour=config.BOT_ERR_COLOUR
            )
            embed.set_author(
                name=config.BOT_AUTHOR_CLICK,
                url=config.BOT_URL,
                icon_url=self.bot.user.avatar_url
            )
            embed.set_footer(
                text=config.BOT_FOOTER
            )
            await ctx.send(embed=embed)

            # Reset cmd cooldown for user to allow another attempt
            ctx.command.reset_cooldown(ctx)
            logger.info(
                "Resetting user cooldown to allow another attempt"
            )
            return

        else:
            embed = discord.Embed(
                title="SUCCESS",
                description="Your suggestion for the developer has been "
                            "received!\nThank you for your input.",
                colour=config.BOT_SUCCESS_COLOUR,
            )
            embed.set_author(
                name=config.BOT_AUTHOR_CLICK,
                url=config.BOT_URL,
                icon_url=self.bot.user.avatar_url
            )
            embed.set_footer(
                text=f"Invoked by {ctx.author.name}#"
                     f"{ctx.author.discriminator}",
                icon_url=ctx.author.avatar_url
            )
            await ctx.message.delete()
            await ctx.send(embed=embed)

        logger.info("Processing New Suggestion")

        # Send suggestion to appropriate channel along with relevant data
        embed = discord.Embed(
            title="NEW SUGGESTION",
            colour=config.BOT_COLOUR,
            timestamp=ctx.message.created_at
        )
        embed.set_author(
            name=config.BOT_AUTHOR_NAME,
            url=config.BOT_URL,
            icon_url=self.bot.user.avatar_url
        )
        embed.add_field(
            name="Details:",
            value=f"User: `{ctx.author.name}#{ctx.author.discriminator}` "
                  f"(ID: `{ctx.author.id}`)"
                  f"\nChannel: `#{ctx.channel.name}` (ID: `{ctx.channel.id}`)"
                  f"\nServer: `{ctx.guild.name}` (ID: `{ctx.guild.id}`)",
            inline=False
        )
        embed.add_field(
            name="Suggestion:",
            value=f"{user_suggestion}",
            inline=False
        )
        embed.set_footer(
            text=f"Suggested by {ctx.author.name}#{ctx.author.discriminator}",
            icon_url=ctx.author.avatar_url
        )
        suggest_msg = await self.suggest_channel.send(embed=embed)
        logger.debug("Suggestion Sent To Channel")

        # Add reactions to allow public participation
        await suggest_msg.add_reaction(config.BOT_EMOJI_UPVOTE)
        await suggest_msg.add_reaction(config.BOT_EMOJI_DOWNVOTE)
        logger.debug("Reactions Added")


def setup(bot):
    bot.add_cog(UtilitiesCog(bot))
